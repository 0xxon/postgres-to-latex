#!/usr/bin/env perl

use 5.10.1;
use strict;
use warnings;

use autodie;
use YAML;
use Number::Format qw(:subs :vars);
use Perl6::Slurp;
use Data::Dumper;
use Getopt::Long;
use Scalar::Util qw/looks_like_number/;

my $data;

sub usage() {
	say STDERR <<EOD;
Script usage:
generateTex [--site sitename] [--queries queryfile] [--notag]

If --queries is not provided, queries are read from queries.yaml.

Will read results from results-[site].yaml and output tex to stdout.

If notag is set, it will not include a site tag in the latex source code.
EOD
	exit(-1);
}

my $site;
my $queryfile;
my $notag = 0;
GetOptions("site=s" => \$site,
	"queries=s" => \$queryfile,
  "notag" => \$notag)
or usage();

$queryfile //= "queries.yaml";
$site //= "";

unless ( -f $queryfile ) {
	die("$queryfile does not exist!");
}
my $resultsfile = "results";
$resultsfile .= "-$site" if ( $site ne "" );
unless (-f "$resultsfile.yaml") {
	say STDERR "$resultsfile.yaml does not exist!\n";
	usage();
}

my $queries_yaml = slurp($queryfile);
my $queries = Load($queries_yaml);
my $results_yaml = slurp("$resultsfile.yaml");
my $results = Load($results_yaml)->{results};

my %c;

say '% AUTOGENERATED FILE. Do not modify!';

for my $q ( @$queries ) {
	next if ( defined($q->{'texignore'}) );
	my $name = $q->{'name'};
	$name =~ y/-//d;
	my $type = $q->{'type'};
	my $addpercentrows = $q->{'addpercent'};
	$addpercentrows //= '';
	my $res = $results->{$name};
	my $origres = $res;
	my $tag = uc($site);
	$tag =~ y/-//d;
	if ( $notag ) {
		$tag = "";
	}
	unless ( defined($res)) {
		say '\newcommand{\\'.$tag.$name.'}[1]{\textbf{XxX}\xspace}';
		say '\newcommand{\\'.$tag.$name.'exact}[1]{\textbf{XxX}\xspace}';
		next;
	}

	if ( !defined($type) ) {

		if ( !defined($q->{'pscale'}) ) {
			$c{$name} = $res;

			my $resexact = format_number($res);
			say '\newcommand{\\'.$tag.$name.'exact}[1]{'.$resexact.'\xspace}';

			$res = format_bytes($res, precision=>1, base=>1000);
		}

		say '\newcommand{\\'.$tag.$name.'}[1]{'.$res.'\xspace}';

		my $ascale = $q->{'apscale'};

		if ( defined($ascale) ) {
			unless ( defined($c{$ascale}) ) {
				say STDERR ("$ascale Not found for $name");
				next;
			}
			my $sres;
			if ( $origres == 0 ) {
				$sres = '0\%';
			} else {
				$sres = ($origres / $c{$ascale}) * 100;
				if ( $sres > 0.0001 ) {
					$sres =~ s/(\.\d\d).*/$1/;
				} else {
					$sres = "0.00";
				}
				$sres .= "\\\%";
			}
			say '\newcommand{\\'.$tag.$name.'percentage}[1]{'.$sres.'\xspace}';
		}

	} elsif ( $type eq 'switch' ) {

		say '\newcommand{\\'.$tag.$name.'}[1]{%';
		my $loop = 0;
		for my $name ( sort keys %$res ) {
			my $count = $res->{$name};
			if ( $loop > 0 ) {
				print '\else';
			}

			print "\\ifnum\\pdfstrcmp{#1}{$name}=0 ";
			if ( $q->{'plain'} ) {
				print $count.'\xspace';
			} else {
				print format_bytes($count, precision=>1, base=>1000).'\xspace';
			}
			$loop++;
		}

		say '\else %';
		say '\textbf{XXX}\xspace %';
		for ( 1..$loop ) {
			print '\fi';
		}
		say "%\n}%";

		my $ascale = $q->{'apscale'};

		if ( defined($ascale) ) {
			say '\newcommand{\\'.$tag.$name.'percentage}[2]{%';
			my $loop = 0;
			while ( my ($name, $count) = each %$res ) {
				if ( $loop > 0 ) {
					print '\else';
				}

				print "\\ifnum\\pdfstrcmp{#1}{$tag$name}=0 ";
				die("$ascale Not found") unless ( defined($c{$ascale}) );
				my $sres;
				if ( $count == 0 ) {
					$sres = '0\%';
				} else {
					$sres = ($count / $c{$ascale}) * 100;
					$sres =~ s/(\.\d\d).*/$1/;
					$sres .= "\\\%";
				}
				print $sres.'\xspace';
				$loop++;
			}
			say '\else %';
			say '\textbf{MISSING NUMBER HERE}\xspace %';
			for ( 1..$loop ) {
				print '\fi';
			}
			say "%\n}%";
		}

	} elsif ( $type eq 'table' )  {
		say STDERR "dumping $name";
		say '\newcommand{\\'.$tag.$name.'}[1]{%';
		my $fields = $res->{fields};
		my $rows = $res->{rows};
		say '\begin{table}';
		say '\small\centering';
		print '\begin{tabular}{@{}';
		for ( 1.. (scalar @$fields) ) {
			print "l";
		}
		say '@{}}';

		print join(' & ', map { s/\_/\\\_/g; '\emph{'.ucfirst($_).'}' } @$fields ); # print fields separated with & end emph'd
		say "\\\\\n\\toprule";
		for my $row ( @$rows ) {
			my @outrow = map {my $a=$_;$a=format_bytes($a,precision=>2,base=>1000,round_style=>'round',precision_cutoff =>2)if(looks_like_number($a));if($a eq "0"){$a='$<0.01$'}$a} @$row;
			for my $i ( split(/,/, $addpercentrows) ) {
				$outrow[$i-1] = $outrow[$i-1].'\%' if looks_like_number($outrow[$i-1]);
			}
			print join (' & ', map { $_ //= "not set"; s/\_/\\\_/g; $_; } @outrow);
			say '\\\\';
		}
		say '\\bottomrule';
		say '\\end{tabular}';
		say '\\caption{#1}';
		say '\\label{tab:'.$tag.$name.'}';
		say '\\end{table}}';
		# also do csname output to be able to lookup by row and column
		my $line = 1;
		for my $row ( @$rows ) {
			my @elem = map { $_ //= "not set"; s/\_/\\\_/g; $_; } @$row;
			my @outrow = map {my $a=$_;$a=format_bytes($a,precision=>2,base=>1000,round_style=>'round',precision_cutoff=>2)if(looks_like_number($a));$a} @$row;
			for my $i ( split(/,/, $addpercentrows) ) {
				$outrow[$i-1] = $outrow[$i-1].'\%' if looks_like_number($outrow[$i-1]);
			}
			for my $i ( 1..(scalar @elem) ) {
				say "\\expandafter\\def\\csname store$tag$name-$i-$line-\\endcsname{$outrow[$i-1]}";
			}
			$line++;
		}
		say '\\def\\'.$tag.$name."lines#1#2{\\ifcsname store$tag$name-#1-#2-\\endcsname\\csname store$tag$name-#1-#2-\\endcsname\\else\\textbf{XxX}\\fi}"
	} else {
		die ("Unknown type $type");
	}
}
